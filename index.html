<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Linear Wave Theory • Interactive Wave Field (Dispersion)</title>
<style>
  :root{
    --bg:#0c1623; --panel:#101c2b; --ink:#e8f0ff; --muted:#a9bbd9;
    --accent:#40c4ff; --accent2:#b388ff; --good:#2bd67b; --warn:#ffcf5c; --bad:#ff6363;
    --grid:#1a2a40; --border:#0f2236;
  }
  *{box-sizing:border-box}
  html,body{
  margin:0;height:100%;
  background:var(--bg);color:var(--ink);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
  font-size: 18px;   
}
  .app{display:grid;grid-template-columns:360px 1fr;grid-template-rows:auto 1fr;
    grid-template-areas:"toolbar toolbar" "panel canvas";height:100vh}
  header{grid-area:toolbar;display:flex;align-items:center;gap:14px;padding:12px 16px;
    border-bottom:1px solid var(--border);background:linear-gradient(180deg,#0f2032,#0d1b2b)}
  header h1{font-size:20px;margin:0;font-weight:650;letter-spacing:.2px}
  header .badge{font-size:12px;color:var(--muted)}
  #status{margin-left:auto;font-size:14px;color:var(--muted)}
  aside.panel{grid-area:panel;background:var(--panel);border-right:1px solid var(--border);
    padding:14px 14px 18px;overflow:auto}
  .group{margin-bottom:16px;padding-bottom:12px;border-bottom:1px dashed #223654}
  .group:last-child{border-bottom:none}
  .group h3{margin:0 0 8px 0;font-size:13px;color:#cfe2ff;text-transform:uppercase;letter-spacing:.8px}
  label{display:flex;align-items:center;gap:8px;margin:6px 0 8px 0;font-size:16px;color:var(--ink)}
  input[type="range"], input[type="number"], select, button{
    width:100%;background:#0b1a29;color:var(--ink);border:1px solid #1e3350;border-radius:10px;
    padding:8px 10px;font-size:14px;outline:none
  }
  input[type="range"]{padding:0;height:32px}
  input[type="number"]{padding:7px 10px}
  button{cursor:pointer;transition:.15s ease background,.15s ease transform}
  button:hover{background:#0f2338}
  button:active{transform:translateY(1px)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .row-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  .muted{color:var(--muted);font-size:12.5px;line-height:1.35}
  .kbd{display:inline-block;border:1px solid #27476f;background:#0d1d30;border-radius:6px;padding:2px 6px;font-size:12px}
  .metric{background:#0d1d30;border:1px solid #1d3556;border-radius:10px;padding:10px 10px;font-size:13px;color:#d8e6ff}
  .metric b{color:#ffffff}
  .chipbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .chip{display:inline-flex;align-items:center;gap:8px;background:#0d1d30;border:1px solid #1d3556;border-radius:999px;padding:6px 10px;font-size:12.5px}
  .dot{width:12px;height:12px;border-radius:50%}
  .dot.a{background:var(--accent)} .dot.b{background:var(--accent2)} .dot.c{background:var(--warn)} .dot.d{background:var(--good)}
  .canvas-wrap{grid-area:canvas;position:relative}
  canvas#view{display:block;width:100%;height:100%;background:conic-gradient(from 180deg at 50% 50%,#0c1726,#0b1a2b 40%,#0b1a2b 60%,#0c1726)}
  .overlay{
    position:absolute;left:14px;top:14px;pointer-events:none;
    font-size:15px;color:#d8e6ff;background:rgba(13,29,48,0.72);border:1px solid rgba(29,53,86,0.85);
    padding:10px 10px;border-radius:12px;backdrop-filter:blur(2px);
    max-width:min(520px,calc(100% - 28px));
  }
  .overlay .line{display:flex;gap:10px;flex-wrap:wrap}
  .overlay .line span{white-space:nowrap}
  .overlay b{color:#fff}
  .help{
    margin-top:8px;font-size:12px;color:#bed3ff
  }
</style>
</head>
<body>
<div class="app">

  <header>
    <h1>Linear Wave Theory</h1>
    <span class="badge">wave field + dispersion (ω² = g k tanh(kh))</span>
    <div id="status">Running</div>
  </header>

  <aside class="panel" aria-label="Controls">
    <div class="group">
      <h3>Wave Parameters</h3>

      <div class="row">
        <div>
          <label for="T">Period T (s)</label>
          <input type="range" id="T" min="1" max="25" step="0.1" value="8.0" />
          <div class="muted">Shortcut: <span class="kbd">[</span> / <span class="kbd">]</span></div>
        </div>
        <div>
          <label for="h">Depth h (m)</label>
          <input type="range" id="h" min="0.5" max="200" step="0.5" value="20" />
          <div class="muted">Shortcut: <span class="kbd">-</span> / <span class="kbd">=</span></div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="a">Amplitude a (m)</label>
          <input type="range" id="a" min="0.01" max="2.5" step="0.01" value="0.6" />
          <div class="muted">Small amplitude → linear theory is best.</div>
        </div>
        <div>
          <label for="g">Gravity g (m/s²)</label>
          <input type="number" id="g" min="1" max="30" step="0.01" value="9.81" />
          <div class="muted">Default is Earth gravity.</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="viewN">View width (in wavelengths)</label>
          <input type="range" id="viewN" min="1" max="6" step="0.25" value="3.0" />
          <div class="muted">Keeps ~constant number of crests on-screen.</div>
        </div>
        <div>
          <label for="speed">Animation speed</label>
          <input type="range" id="speed" min="0.1" max="3.0" step="0.1" value="1.0" />
          <div class="muted">Shortcut: <span class="kbd">Space</span> pause</div>
        </div>
      </div>

    </div>

    <div class="group">
      <h3>Computed from Dispersion</h3>
      <div class="metric" id="metrics">—</div>
      <div class="chipbar" aria-label="Legend">
        <span class="chip"><span class="dot a"></span>u, w velocity arrows</span>
        <span class="chip"><span class="dot b"></span>color field (selected)</span>
        <span class="chip"><span class="dot c"></span>free surface η(x,t)</span>
        <span class="chip"><span class="dot d"></span>tracer particles</span>
      </div>
    </div>

    <div class="group">
      <h3>Visualization Options</h3>
      <label for="field">Color field (in water column)
        <select id="field">
          <option value="none">None</option>
          <option value="phi">Velocity potential ϕ</option>
          <option value="u">Horizontal velocity u</option>
          <option value="w">Vertical velocity w</option>
          <option value="pdyn">Dynamic pressure p' (scaled by ρ)</option>
        </select>
      </label>

      <div class="row">
        <label style="margin:0">
          <input type="checkbox" id="arrows" checked style="width:auto" />
          <span>Show velocity arrows</span>
        </label>
        <label style="margin:0">
          <input type="checkbox" id="tracers" checked style="width:auto" />
          <span>Show tracers</span>
        </label>
      </div>

      <div class="row">
        <button id="resetTracers">Reset tracers</button>
        <button id="resetTime">Reset time</button>
      </div>

      <div class="help">
        Click in the water to add a tracer at that mean position (X<sub>0</sub>, Z<sub>0</sub>).<br>
        Shortcuts: <span class="kbd">Space</span> pause · <span class="kbd">R</span> reset tracers · <span class="kbd">0</span> reset time
      </div>
    </div>

    <div class="group">
      <h3>What this demo assumes</h3>
      <div class="muted">
        Plane progressive wave in +x with small amplitude (linear theory). Flat seabed at constant depth h.
        Uses the lecture-note formulas for η(x,t), dispersion, and ϕ(x,z,t), then derives u=∂ϕ/∂x and w=∂ϕ/∂z.
      </div>
    </div>

  </aside>

  <div class="canvas-wrap">
    <canvas id="view" aria-label="Wave field visualization"></canvas>
    <div class="overlay" id="overlay"></div>
  </div>

</div>

<script>
"use strict";

/* =========================================================
   Coordinate systems:
   - world: x (m) positive right, z (m) positive up, mean free surface at z=0
   - screen: px, py with py positive down
   ========================================================= */

const canvas = document.getElementById("view");
const ctx = canvas.getContext("2d", { alpha:false });
let DPR = Math.max(1, window.devicePixelRatio || 1);

const state = {
  t: 0,
  paused: false,
  last: performance.now(),
  speed: 1.0,

  // parameters
  a: 0.6,   // amplitude [m]
  T: 20.0,   // period [s]
  h: 20.0,  // depth [m]
  g: 9.81,

  // derived
  omega: 0,
  k: 0,
  lambda: 0,
  c: 0,
  cg: 0,
  kh: 0,
  regime: "",

  // view window width in wavelengths
  viewN: 3.0,

  // display options
  showArrows: true,
  showTracers: true,
  field: "pdyn",

  // tracers: mean positions + trail
  tracers: [],
  trailMax: 220
};

const view = { W: 0, H: 0 };
const world = {
  x0: 0,
  x1: 1,
  z0: -20,
  z1: +3
};

/* ===== Utilities ===== */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function fmt(x, n=3){
  if (!Number.isFinite(x)) return "—";
  const abs = Math.abs(x);
  if (abs !== 0 && (abs < 1e-3 || abs > 1e4)) return x.toExponential(n);
  return x.toFixed(n);
}

function hexToRgb(hex){
  const h = hex.replace("#","");
  const n = parseInt(h,16);
  const r = (n>>16)&255, g=(n>>8)&255, b=n&255;
  return {r,g,b};
}
const rgbBg = hexToRgb("#0b1a29");
const rgbA  = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--accent").trim());
const rgbB  = hexToRgb(getComputedStyle(document.documentElement).getPropertyValue("--accent2").trim());

function mixRGB(c0, c1, t){
  t = clamp(t,0,1);
  return {
    r: Math.round(lerp(c0.r,c1.r,t)),
    g: Math.round(lerp(c0.g,c1.g,t)),
    b: Math.round(lerp(c0.b,c1.b,t))
  };
}
function rgba(c, a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

/* ===== Resizing ===== */
function resize(){
  DPR = Math.max(1, window.devicePixelRatio || 1);

  const rect = canvas.parentElement.getBoundingClientRect();
  view.W = Math.max(760, rect.width | 0);
  view.H = Math.max(520, rect.height | 0);

  canvas.width  = (view.W * DPR) | 0;
  canvas.height = (view.H * DPR) | 0;
  canvas.style.width  = view.W + "px";
  canvas.style.height = view.H + "px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener("resize", resize);
resize();

/* ===== World ↔ screen mapping ===== */
function toScreen(x, z){
  const px = (x - world.x0) / (world.x1 - world.x0) * view.W;
  const py = (world.z1 - z) / (world.z1 - world.z0) * view.H;
  return {x:px, y:py};
}
function toWorld(px, py){
  const x = world.x0 + (px / view.W) * (world.x1 - world.x0);
  const z = world.z1 - (py / view.H) * (world.z1 - world.z0);
  return {x,z};
}
function inWater(z){ return z <= 0 && z >= -state.h; }

/* =========================================================
   Physics (linear wave theory)
   η(x,t) = a cos(k x − ω t)
   dispersion: ω² = g k tanh(k h)
   ϕ(x,z,t) = (a g / ω) * cosh[k(z+h)]/cosh(kh) * sin(kx − ωt)
   u = ∂ϕ/∂x,  w = ∂ϕ/∂z
   ========================================================= */

function solveWaveNumber(omega, h, g){
  // Robust solver for k > 0 given ω, h, g
  if (!(omega>0) || !(h>0) || !(g>0)) return NaN;

  const shallow = omega / Math.sqrt(g*h);
  const deep = (omega*omega) / g;
  let k = (deep*h < 1.0) ? shallow : deep;
  k = Math.max(k, 1e-8);

  const maxIter = 30;
  for (let i=0;i<maxIter;i++){
    const kh = k*h;
    const th = Math.tanh(kh);
    const sech = 1/Math.cosh(kh);
    const sech2 = sech*sech;

    const f  = omega*omega - g*k*th;
    const df = -g*(th + kh*sech2);

    const step = f/df;
    k -= step;

    if (!Number.isFinite(k) || k<=0) break;
    if (Math.abs(step) < 1e-12*Math.max(1,k)) return k;
  }

  // Bisection fallback
  let lo = 0.0;
  let hi = Math.max(deep, shallow, 1e-6);
  function fK(kk){
    return omega*omega - g*kk*Math.tanh(kk*h);
  }
  // find hi such that f(hi) < 0
  let fhi = fK(hi);
  let guard = 0;
  while (fhi > 0 && guard++ < 80){
    hi *= 2;
    fhi = fK(hi);
    if (hi > 1e7) break;
  }
  if (!(fhi < 0)) return NaN;

  for (let it=0; it<70; it++){
    const mid = 0.5*(lo+hi);
    const fm = fK(mid);
    if (fm > 0) lo = mid; else hi = mid;
  }
  return 0.5*(lo+hi);
}

function updateDerived(){
  state.omega = 2*Math.PI / state.T;
  state.k = solveWaveNumber(state.omega, state.h, state.g);

  if (!Number.isFinite(state.k) || state.k <= 0){
    state.lambda = NaN; state.c = NaN; state.cg = NaN; state.kh = NaN; state.regime = "—";
    return;
  }

  state.lambda = 2*Math.PI / state.k;
  state.c = state.omega / state.k;

  state.kh = state.k * state.h;
  const kh = state.kh;
  const n = 0.5 * (1 + (2*kh)/Math.sinh(2*kh)); // group factor
  state.cg = n * state.c;

  // Regime thresholds (dimensionless):
  // - shallow: kh < π/10
  // - deep:    kh > π
  const khShallow = Math.PI / 10;
  const khDeep = Math.PI;

  if (kh < khShallow) state.regime = "shallow (kh < π/10)";
  else if (kh > khDeep) state.regime = "deep (kh > π)";
  else state.regime = "intermediate";

  // update view extents based on wavelength and depth
  const Lx = state.viewN * state.lambda;
  world.x0 = 0;
  world.x1 = Lx;

  world.z0 = -state.h;
  // show a bit of air above mean surface, but don't let it dwarf the plot
  const zTop = Math.max(2*state.a, 0.12*state.h, 0.6);
  world.z1 = zTop;
}

function phase(x, t){ return state.k*x - state.omega*t; }
function eta(x, t){ return state.a * Math.cos(phase(x,t)); }

function phi(x, z, t){
  const kh = state.k * state.h;
  const kz = state.k * (z + state.h);
  return (state.a * state.g / state.omega) * (Math.cosh(kz) / Math.cosh(kh)) * Math.sin(phase(x,t));
}
function uVel(x, z, t){
  const kh = state.k * state.h;
  const kz = state.k * (z + state.h);
  return (state.a * state.g * state.k / state.omega) * (Math.cosh(kz) / Math.cosh(kh)) * Math.cos(phase(x,t));
}
function wVel(x, z, t){
  const kh = state.k * state.h;
  const kz = state.k * (z + state.h);
  return (state.a * state.g * state.k / state.omega) * (Math.sinh(kz) / Math.cosh(kh)) * Math.sin(phase(x,t));
}
function pDynOverRho(x, z, t){
  // dynamic pressure / ρ = -∂ϕ/∂t
  const kh = state.k * state.h;
  const kz = state.k * (z + state.h);
  return (state.a * state.g) * (Math.cosh(kz) / Math.cosh(kh)) * Math.cos(phase(x,t));
}

/* ===== Field selection for color map ===== */
function fieldValue(kind, x, z, t){
  if (kind === "phi") return phi(x,z,t);
  if (kind === "u") return uVel(x,z,t);
  if (kind === "w") return wVel(x,z,t);
  if (kind === "pdyn") return pDynOverRho(x,z,t);
  return 0;
}
function fieldScale(kind){
  if (kind === "phi") return (state.a * state.g / state.omega);
  if (kind === "u") return (state.a * state.g * state.k / state.omega);
  if (kind === "w") return (state.a * state.g * state.k / state.omega) * Math.tanh(state.k*state.h);
  if (kind === "pdyn") return (state.a * state.g);
  return 1;
}

/* ===== Drawing helpers ===== */
function drawArrow(px, py, vx, vy){
  const L = Math.hypot(vx,vy);
  if (L < 1e-9) return;
  const ang = Math.atan2(vy,vx);
  const head = Math.max(6, Math.min(12, L*0.30));
  const tx = px + vx, ty = py + vy;

  ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(tx,ty); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(tx,ty);
  ctx.lineTo(tx - head*Math.cos(ang - Math.PI/6), ty - head*Math.sin(ang - Math.PI/6));
  ctx.lineTo(tx - head*Math.cos(ang + Math.PI/6), ty - head*Math.sin(ang + Math.PI/6));
  ctx.closePath(); ctx.fill();
}

function drawAxesAndGrid(){
  // subtle grid in screen coords
  ctx.save();
  ctx.strokeStyle = "rgba(80,120,180,0.12)";
  ctx.lineWidth = 1;

  const gx = Math.round(view.W/12);
  const gy = Math.round(view.H/10);
  for (let x=0; x<=view.W; x+=gx){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,view.H); ctx.stroke(); }
  for (let y=0; y<=view.H; y+=gy){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(view.W,y); ctx.stroke(); }
  ctx.restore();

  // x-axis ticks at bottom of plot area (z=z0)
  ctx.save();
  ctx.strokeStyle = "rgba(200,220,255,0.35)";
  ctx.fillStyle   = "rgba(200,220,255,0.70)";
  ctx.lineWidth = 1;

  const y0 = toScreen(world.x0, world.z0).y;
  const tickCount = 5;
  for (let i=0;i<=tickCount;i++){
    const xw = world.x0 + (i/tickCount)*(world.x1-world.x0);
    const p = toScreen(xw, world.z0);
    ctx.beginPath(); ctx.moveTo(p.x, y0); ctx.lineTo(p.x, y0-8); ctx.stroke();
    ctx.fillText(`${fmt(xw,0)} m`, p.x+2, y0-10);
  }
  ctx.restore();
}

function drawBathymetry(){
  const pL = toScreen(world.x0, -state.h);
  const pR = toScreen(world.x1, -state.h);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.7)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(pL.x, pL.y); ctx.lineTo(pR.x, pR.y); ctx.stroke();
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  ctx.fillText(`      seabed z = −h = −${fmt(state.h,1)} m`, pL.x+8, pL.y-10);
  ctx.restore();
}

function drawMeanSurface(){
  const pL = toScreen(world.x0, 0);
  const pR = toScreen(world.x1, 0);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(pL.x, pL.y); ctx.lineTo(pR.x, pR.y); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = "rgba(255,255,255,0.5)";
  ctx.fillText("mean surface z = 0", pL.x+8, pL.y-8);
  ctx.restore();
}

function drawFreeSurface(t){
  const N = Math.max(300, Math.floor(view.W/2));
  ctx.save();
  ctx.strokeStyle = "rgba(255,207,92,0.95)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i=0;i<=N;i++){
    const x = world.x0 + (i/N)*(world.x1-world.x0);
    const z = eta(x,t);
    const p = toScreen(x,z);
    if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();

  // light fill for water (under the instantaneous surface, but approximated)
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = "rgba(64,196,255,1)";
  ctx.lineTo(toScreen(world.x1, world.z0).x, toScreen(world.x1, world.z0).y);
  ctx.lineTo(toScreen(world.x0, world.z0).x, toScreen(world.x0, world.z0).y);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawColorField(t){
  if (state.field === "none") return;

  const kind = state.field;
  const scale = fieldScale(kind) || 1;
  const nx = 64;
  const nz = 32;

  // draw only in the water column z∈[-h,0]
  const zTop = 0;
  const zBot = -state.h;

  ctx.save();
  // slightly transparent so grid & lines are visible
  const alphaBase = 0.90;

  for (let iz=0; iz<nz; iz++){
    const z0 = zBot + (iz/nz)*(zTop - zBot);
    const z1 = zBot + ((iz+1)/nz)*(zTop - zBot);
    const zc = 0.5*(z0+z1);

    const p0 = toScreen(world.x0, z0);
    const p1 = toScreen(world.x1, z1);

    // Convert this z-strip to screen y bounds
    const yTop = Math.min(p0.y, p1.y);
    const yBot = Math.max(p0.y, p1.y);
    const hPx = (yBot - yTop);

    for (let ix=0; ix<nx; ix++){
      const x0 = world.x0 + (ix/nx)*(world.x1-world.x0);
      const x1 = world.x0 + ((ix+1)/nx)*(world.x1-world.x0);
      const xc = 0.5*(x0+x1);

      const v = fieldValue(kind, xc, zc, t);
      let s = (scale>0) ? (v/scale) : 0;
      s = clamp(s, -1, 1);

      const strength = Math.pow(Math.abs(s), 0.75);
      const rgb = (s>=0) ? mixRGB(rgbBg, rgbA, strength) : mixRGB(rgbBg, rgbB, strength);

      ctx.fillStyle = rgba(rgb, alphaBase);
      const pA = toScreen(x0, z0);
      const pB = toScreen(x1, z1);
      const xPx = Math.abs(pB.x - pA.x);
      ctx.fillRect(Math.min(pA.x, pB.x), yTop, xPx+1, hPx+1);
    }
  }

  // label
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(232,240,255,0.85)";
  const name = ({
    phi:"ϕ (velocity potential)",
    u:"u (horizontal velocity)",
    w:"w (vertical velocity)",
    pdyn:"p' / ρ (dynamic pressure)"
  })[kind] || kind;

  ctx.fillText(`Color field: ${name}`, 14, view.H-18);
  ctx.restore();
}

function drawVelocityArrows(t){
  if (!state.showArrows) return;

  const nx = 22;
  const nz = 10;
  const zTop = 0;
  const zBot = -state.h;

  // choose a screen scaling so arrows look nice
  const umax = Math.max(1e-9, fieldScale("u")); // representative magnitude
  const wmax = Math.max(1e-9, fieldScale("w"));
  const vref = Math.max(umax, wmax);

  ctx.save();
  ctx.strokeStyle = "rgba(64,196,255,0.85)";
  ctx.fillStyle = "rgba(64,196,255,0.85)";
  ctx.lineWidth = 1.2;

  for (let iz=0; iz<=nz; iz++){
    const z = zBot + (iz/nz)*(zTop - zBot);
    for (let ix=0; ix<=nx; ix++){
      const x = world.x0 + (ix/nx)*(world.x1-world.x0);

      // Only draw arrows inside the *instantaneous* water domain:
      // seabed: z >= -h  (already true by construction)
      // free surface: z <= η(x,t)
      const zSurf = eta(x, t);
      if (z > zSurf) continue;

      const u = uVel(x, z, t);
      const w = wVel(x, z, t);

      // scale to pixels
      const p = toScreen(x,z);
      const mag = Math.hypot(u,w);
      const Lpx = 18 * (mag / (vref + 1e-12));
      if (Lpx < 1.2) continue;

      let dx = Lpx * (u / (mag + 1e-12));
      let dy = -Lpx * (w / (mag + 1e-12));

      // If an arrow would poke above the instantaneous free surface, clip it.
      // (Clipping is done at the same x in screen space; this is accurate enough for short arrows.)
      if (dy < 0){
        const pSurf = toScreen(x, zSurf);
        const yTip = p.y + dy;
        const yMax = pSurf.y + 1.0; // keep ~1px below the surface line
        if (yTip < yMax){
          const s = (yMax - p.y) / dy; // dy < 0 ⇒ 0 < s < 1
          if (!(s > 0)) continue;
          dx *= s;
          dy *= s;
          if (Math.hypot(dx,dy) < 1.2) continue;
        }
      }

      drawArrow(p.x, p.y, dx, dy);
    }
  }
  ctx.restore();
}


/* ===== Tracers ===== */
function makeDefaultTracers(){
  state.tracers = [];
  // mean positions on a grid
  const nX = 10;
  const levels = [-0.2, -0.6, -0.85]; // relative depths
  for (let j=0;j<levels.length;j++){
    const z = levels[j]*state.h;
    for (let i=0;i<nX;i++){
      const x = (i/(nX-1))* (state.viewN*state.lambda);
      state.tracers.push({X0:x, Z0:z, trail:[]});
    }
  }
}

function tracerPos(tr, t){
  // linear particle motion about mean (X0,Z0) using analytic integration of u,w
  const kh = state.k * state.h;
  const denom = Math.sinh(kh);
  const A = (denom !== 0) ? (state.a / denom) : 0;

  const kz0 = state.k * (tr.Z0 + state.h);
  const dxAmp = A * Math.cosh(kz0);
  const dzAmp = A * Math.sinh(kz0);

  const ph = state.k*tr.X0 - state.omega*t;

  const x = tr.X0 - dxAmp * Math.sin(ph);
  const z = tr.Z0 + dzAmp * Math.cos(ph);

  return {x,z};
}

function updateTracers(t){
  if (!state.showTracers) return;
  for (const tr of state.tracers){
    const p = tracerPos(tr, t);
    tr.trail.push(p);
    if (tr.trail.length > state.trailMax) tr.trail.shift();
  }
}

function drawTracers(){
  if (!state.showTracers) return;

  ctx.save();
  ctx.strokeStyle = "rgba(43,214,123,0.8)";
  ctx.fillStyle = "rgba(43,214,123,0.95)";
  ctx.lineWidth = 1.6;

  for (const tr of state.tracers){
    // trail
    if (tr.trail.length > 2){
      ctx.beginPath();
      const p0 = toScreen(tr.trail[0].x, tr.trail[0].z);
      ctx.moveTo(p0.x,p0.y);
      for (let i=1;i<tr.trail.length;i++){
        const p = toScreen(tr.trail[i].x, tr.trail[i].z);
        ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
    }

    // current dot
    if (tr.trail.length){
      const cur = tr.trail[tr.trail.length-1];
      const pc = toScreen(cur.x, cur.z);
      ctx.beginPath();
      ctx.arc(pc.x, pc.y, 3.2, 0, 2*Math.PI);
      ctx.fill();
    }
  }

  ctx.restore();
}

/* ===== Overlay text ===== */
function updateOverlay(){
  const overlay = document.getElementById("overlay");
  const Lx = world.x1 - world.x0;

  overlay.innerHTML = `
    <div class="line">
      <span><b>T</b> = ${fmt(state.T,2)} s</span>
      <span><b>h</b> = ${fmt(state.h,1)} m</span>
      <span><b>a</b> = ${fmt(state.a,2)} m</span>
      <span><b>g</b> = ${fmt(state.g,2)} m/s²</span>
    </div>
    <div class="line" style="margin-top:6px">
      <span><b>ω</b> = ${fmt(state.omega,3)} rad/s</span>
      <span><b>k</b> = ${fmt(state.k,4)} 1/m</span>
      <span><b>λ</b> = ${fmt(state.lambda,2)} m</span>
      <span><b>c</b> = ${fmt(state.c,2)} m/s</span>
      <span><b>c<sub>g</sub></b> = ${fmt(state.cg,2)} m/s</span>
    </div>
    <div class="line" style="margin-top:6px">
      <span><b>kh</b> = ${fmt(state.kh,3)}</span>
      <span><b>regime</b>: ${state.regime}</span>
      <span><b>view</b>: ${fmt(Lx,1)} m (≈ ${fmt(state.viewN,2)} λ)</span>
    </div>
  `;
}

/* ===== Metrics card ===== */
function updateMetricsCard(){
  const m = document.getElementById("metrics");
  if (!Number.isFinite(state.k)){
    m.textContent = "Could not solve dispersion (check parameters).";
    return;
  }

  // asymptotic phase speeds
  const cShallow = Math.sqrt(state.g * state.h);
  const cDeep = Math.sqrt(state.g / state.k);

  const msg = `
    <div><b>Dispersion</b>: ω² = g k tanh(kh)</div>
    <div style="margin-top:6px">
      <b>Solution</b>: k = ${fmt(state.k,6)} 1/m → λ = ${fmt(state.lambda,3)} m, c = ${fmt(state.c,3)} m/s
    </div>
    <div style="margin-top:6px">
      <b>Dimensionless</b>: kh = ${fmt(state.kh,3)} → ${state.regime}
    </div>
    <div style="margin-top:6px">
      <b>Limits</b>: shallow c ≈ √(gh) = ${fmt(cShallow,3)} m/s · deep c ≈ √(g/k) = ${fmt(cDeep,3)} m/s
    </div>
  `;
  m.innerHTML = msg;
}

/* ===== UI wiring ===== */
const elT = document.getElementById("T");
const elH = document.getElementById("h");
const elA = document.getElementById("a");
const elG = document.getElementById("g");
const elViewN = document.getElementById("viewN");
const elSpeed = document.getElementById("speed");
const elField = document.getElementById("field");
const elArrows = document.getElementById("arrows");
const elTracers = document.getElementById("tracers");
const btnResetTracers = document.getElementById("resetTracers");
const btnResetTime = document.getElementById("resetTime");
const statusEl = document.getElementById("status");

function refreshFromUI(){
  state.T = parseFloat(elT.value);
  state.h = parseFloat(elH.value);
  state.a = parseFloat(elA.value);
  state.g = parseFloat(elG.value);
  state.viewN = parseFloat(elViewN.value);
  state.speed = parseFloat(elSpeed.value);
  state.field = elField.value;
  state.showArrows = !!elArrows.checked;
  state.showTracers = !!elTracers.checked;

  updateDerived();
  updateOverlay();
  updateMetricsCard();
  // keep tracers consistent with new wavelength/depth if none exist
  if (state.tracers.length === 0) makeDefaultTracers();
}

[elT, elH, elA, elG, elViewN, elSpeed, elField].forEach(el => el.addEventListener("input", refreshFromUI));
[elArrows, elTracers].forEach(el => el.addEventListener("change", refreshFromUI));

btnResetTracers.addEventListener("click", ()=>{
  makeDefaultTracers();
  statusEl.textContent = "Tracers reset";
});
btnResetTime.addEventListener("click", ()=>{
  state.t = 0;
  for (const tr of state.tracers) tr.trail = [];
  statusEl.textContent = "Time reset";
});

/* ===== Interaction: click to add tracer ===== */
canvas.addEventListener("mousedown", (ev)=>{
  const r = canvas.getBoundingClientRect();
  const p = toWorld(ev.clientX - r.left, ev.clientY - r.top);
  if (!inWater(p.z)) { statusEl.textContent = "Click inside the water column (z between −h and 0)"; return; }

  // mean position uses clicked coordinates as X0,Z0
  const tr = { X0: clamp(p.x, world.x0, world.x1), Z0: clamp(p.z, -state.h, 0), trail:[] };
  state.tracers.push(tr);
  statusEl.textContent = `Tracer added at (X0,Z0)=(${fmt(tr.X0,2)} m, ${fmt(tr.Z0,2)} m)`;
});

/* ===== Shortcuts ===== */
window.addEventListener("keydown", (e)=>{
  const k = e.key;
  if (k === " "){
    state.paused = !state.paused;
    statusEl.textContent = state.paused ? "Paused" : "Running";
    e.preventDefault();
  } else if (k.toLowerCase() === "r"){
    makeDefaultTracers();
    statusEl.textContent = "Tracers reset";
  } else if (k === "0"){
    state.t = 0;
    for (const tr of state.tracers) tr.trail = [];
    statusEl.textContent = "Time reset";
  } else if (k === "["){
    state.T = clamp(state.T - 0.2, parseFloat(elT.min), parseFloat(elT.max));
    elT.value = state.T; refreshFromUI();
  } else if (k === "]"){
    state.T = clamp(state.T + 0.2, parseFloat(elT.min), parseFloat(elT.max));
    elT.value = state.T; refreshFromUI();
  } else if (k === "-" ){
    state.h = clamp(state.h - 1.0, parseFloat(elH.min), parseFloat(elH.max));
    elH.value = state.h; refreshFromUI();
  } else if (k === "="){
    state.h = clamp(state.h + 1.0, parseFloat(elH.min), parseFloat(elH.max));
    elH.value = state.h; refreshFromUI();
  }
});

/* ===== Main loop ===== */
function frame(now){
  const dtReal = Math.min(0.05, (now - state.last)/1000);
  state.last = now;

  if (!state.paused){
    state.t += dtReal * state.speed;
    updateTracers(state.t);
  }

  // draw
  ctx.fillStyle = "#0a1522";
  ctx.fillRect(0,0,view.W,view.H);

  drawColorField(state.t);
  drawAxesAndGrid();
  drawBathymetry();
  drawMeanSurface();
  drawFreeSurface(state.t);
  drawVelocityArrows(state.t);
  drawTracers();

  requestAnimationFrame(frame);
}

/* ===== Init ===== */
(function init(){
  makeDefaultTracers();
  refreshFromUI();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
